<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>云海阁</title>
    <link>https://zouni.vip/docs/document/embedded/</link>
    <description>Recent content on 云海阁</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://zouni.vip/docs/document/embedded/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://zouni.vip/docs/document/embedded/51/%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9B%E5%BB%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zouni.vip/docs/document/embedded/51/%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9B%E5%BB%BA/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://zouni.vip/docs/document/embedded/stm32/clion%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zouni.vip/docs/document/embedded/stm32/clion%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>#clion+ stm32 开发环境搭建参考jetbrains官方指导
#准备#1. clion#2. gcc-arm-none-eabi下载 gcc-arm-none-eabi-10.3-2021.10-win32.exe 一键安装：最后一步勾选（path添加到环境变量，否则编译程序找不到编译器）
#3. mingw-get-setup.exe安装之后，配置clion Toolchains 环境就可以了
#4. stm32cubemx-win.zip这一步没什么特殊 一键安装
#5. OpenOCD#5.1 openOCD 配置配置ST-link烧写器配置文件 stm32f103_stlink.cfg
source [find interface/stlink.cfg]transport select hla_swdsource [find target/stm32f1x.cfg]adapter speed 2000 // adapter_khz 2000 保存到openOCD脚本目录下： D:\WorkRoom\embedded\stm32\OpenOCD-20210729-0.11.0\share\openocd\scripts\board</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zouni.vip/docs/document/embedded/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zouni.vip/docs/document/embedded/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</guid>
      <description>#串口引脚定义 DTR : 数据终端准备好 RTS: 请求发送 RXD: 接收 TXD: 发送 CTS: 清除发送  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://zouni.vip/docs/document/embedded/%E5%90%84%E7%A7%8D%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zouni.vip/docs/document/embedded/%E5%90%84%E7%A7%8D%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/</guid>
      <description>#TTL  输出 1 :=&amp;gt; 电压大于等于 2.4v 0 :=&amp;gt; 电压小于等于 0.4v
  输入 1 :=&amp;gt; 电压大于等于2.0v 0 :=&amp;gt; 电压小于等于0.8v
  TTL器件输出低电平要小于0.8V，高电平要大于2.4V。输入，低于1.2V就认为是0，高于2.0就认为是1。于是TTL电平的输入低电平的噪声容限（噪声容限是指在前一极输出为最坏的情况下，为保证后一极正常工作，所允许的最大噪声幅度 。噪声容限越大说明容许的噪声越大，电路的抗干扰性越好 。）就只有（0.8-0）/2=0.4V，高电平的噪声容限为（5-2.4）/2=1.3V。
#CMOS  输出 L：0 &amp;lt;0.1Vcc ； 1 H：&amp;gt;0.9Vcc。
  输入 L：0 &amp;lt;0.3Vcc ； 1 H：&amp;gt;0.7Vcc.
  由于CMOS电源采用12V，则输入低于3.6V为低电平，噪声容限为1.8V，高于3.5V为高电平，噪声容限高为1.8V。比TTL有更高的噪声容限。
CMOS电平能够驱动TTL电平；
TTL电平不能驱动CMOS电平，需要加上拉电阻
#RS232 逻辑1的电平为-3～-15V，逻辑0的电平为+3～+15V，注意电平的定义反相了一次。  RS232的电平标准为+12V为逻辑负，-12为逻辑正，TTL电平为5V为逻辑正，0为逻辑负
#RS485 RS485采用差分信号负逻辑，逻辑&amp;quot;1”以两线间的电压差为-(2~6)V表示;逻辑&amp;quot;0&amp;quot;以两线间的电压差为+(2~6)V表示。  TTL接口电平常见的有3.3V和5V的。通过在0和TTL电平之间摆动，来传输数据。需要通讯双方“约定”好速率。也就是说，通过TTL电平传输的UART接口是一种不传输时钟的&amp;quot;异步通讯&amp;quot;方式。
而RS485接口，简单说就是把TTL的“0-3.3V/5V之间摆动”的信号，转换为“5V压差颠倒反转的AB线信号”，并且扩流驱动电缆电容。简单说就是这样。
所以可以理解为，RS485是以TTL数据源的总线驱动芯片。
RS485采用差分信号逻辑，更适合长距离、高速传输。
接口信号电平比RS-232-C降低了，就不易损坏接口电路的芯片， 且该电平与TTL电平兼容，可方便与TTL电路连接。</description>
    </item>
    
  </channel>
</rss>
